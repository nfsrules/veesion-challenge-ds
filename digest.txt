Directory structure:
└── veesion-challenge-ds/
    ├── README.md
    ├── main.py
    ├── requirements.txt
    ├── data/
    ├── optimizer/
    │   ├── __init__.py
    │   ├── base_models.py
    │   ├── global_optim.py
    │   ├── io_utils.py
    │   ├── local_optim.py
    │   └── viz_utils.py
    ├── results/
    └── tests/
        └── __init__.py

================================================
File: README.md
================================================
# veesion-challenge-ds


================================================
File: main.py
================================================
# main.py
import argparse
import logging
import os
from optimizer.io_utils import load_dataframe
from optimizer import CameraModel, MultiCameraOptimizer

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(name)s - %(message)s")


def main(args):
    """
    Main entry point for running the multi-camera optimization.

    Steps:
        1. Load data from --source.
        2. Filter for a single camera if --store and --camera_id are provided.
        3. Run optimization with the requested --target_fp_reduction.
        4. Save results if --save_path is specified.
    """

    df = load_dataframe(args.source, source_type=args.source_type)

    if args.camera_id:
        if not args.store:
            logging.error("Must provide --store when using --camera_id")
            return
        df = df[(df['store'] == args.store) & (df['camera_id'] == args.camera_id)]
        if df.empty:
            logging.error(f"No data found for store '{args.store}' and camera_id '{args.camera_id}'")
            return
        logging.info(f"Running optimization for store '{args.store}', camera_id '{args.camera_id}'")
    else:
        logging.info("Running optimization for all cameras")

    optimizer = MultiCameraOptimizer(df, CameraModel, verbose=not args.quiet)
    optimizer.run(target_fp_reduction=args.target_fp_reduction)

    if args.save_path:
        os.makedirs(os.path.dirname(args.save_path), exist_ok=True)
        optimizer.save(args.save_path)
        logging.info(f"Saved optimizer state to {args.save_path}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run Multi-Camera Optimizer")
    parser.add_argument(
        "--source", type=str, required=True,
        help="Data source (e.g., CSV path)"
    )
    parser.add_argument(
        "--source_type", type=str, default="csv", choices=["csv", "db"],
        help="Source type (default: csv)"
    )
    parser.add_argument(
        "--target_fp_reduction", type=int, default=100,
        help="Desired number of false positives to reduce globally (default: 100)"
    )
    parser.add_argument(
        "--store", type=str,
        help="Store name (required if --camera_id is provided)"
    )
    parser.add_argument(
        "--camera_id", type=str,
        help="Camera ID (e.g., '1') to run for a single camera; requires --store"
    )
    parser.add_argument(
        "--save_path", type=str, default="",
        help="Path to save the optimizer's results (JSON). If empty, results won't be saved."
    )
    parser.add_argument(
        "--quiet", action="store_true",
        help="Suppress detailed logs"
    )

    args = parser.parse_args()
    main(args)


================================================
File: requirements.txt
================================================
numpy
pandas
scikit-learn



================================================
File: optimizer/__init__.py
================================================
from .global_optim import MultiCameraOptimizer 
from .local_optim import CameraModel


================================================
File: optimizer/base_models.py
================================================
from abc import ABC, abstractmethod
from datetime import datetime


class BaseCameraModel(ABC):
    """
    Abstract base class for all camera models.
    Defines the interface for training, prediction, evaluation, and persistence.
    """

    def __init__(self, camera_id, store=None):
        self.camera_id = str(camera_id)
        self.store = store
        self.threshold = 0.0
        self.optim_method = None
        self._fitted = False
        self.cost_ratio = float("inf") 
        self.created_at = datetime.now()
        self.updated_at = self.created_at

    @abstractmethod
    def fit(self, X, y, method="greedy", **kwargs):
        pass

    @abstractmethod
    def predict(self, X):
        pass

    @abstractmethod
    def get_metrics(self, X, y, threshold=None):
        pass

    @abstractmethod
    def save(self, path):
        pass

    @classmethod
    @abstractmethod
    def load(cls, path):
        pass

    def __repr__(self):
        return (f"{self.__class__.__name__}(cam={self.camera_id}, th={self.threshold:.2f}, "
                f"method={self.optim_method}, updated={self.updated_at.strftime('%Y-%m-%d %H:%M:%S')})")


class BaseGlobalOptimizer(ABC):
    """
    Abstract base class for global optimizers.
    Defines the interface for runing an optimization with a target #FP reduction and persistence.
    """
    @abstractmethod
    def run(self, target_fp_reduction: int, outdir: str = None):
        pass

    @abstractmethod
    def save(self, path: str):
        pass

    @classmethod
    @abstractmethod
    def load(cls, path: str):
        pass




================================================
File: optimizer/global_optim.py
================================================
import json
import logging

from .base_models import BaseGlobalOptimizer

logger = logging.getLogger(__name__)


class MultiCameraOptimizer(BaseGlobalOptimizer):
    def __init__(self, df, camera_model_cls, verbose=True):
        """
        Args:
            df (pd.DataFrame): Must contain 'store', 'camera_id', 'probability', 'is_theft'.
            verbose (bool): Whether to print fitting logs.
        """
        self.df = df
        self.camera_model_cls = camera_model_cls
        self.verbose = verbose

        self.cameras_info = []
        self.selected = []
        self.skipped = []
        self.total_fp_saved = 0
        self.total_tp_lost = 0
        self.target_fp_reduction = None

        if not self.verbose:
            logger.setLevel(logging.WARNING)

    def _fit_cameras(self):
        for (store, cam_id), group in self.df.groupby(['store', 'camera_id']):
            X = group['probability'].values.astype(float)
            y = group['is_theft'].values
            camera_name = f"{store}_cam{cam_id}"

            camera = self.camera_model_cls(camera_id=camera_name)

            try:
                camera.fit(X, y, method="cost")
                gain = camera.report_gain()

                if gain["fp_saved"] > 0:
                    self.cameras_info.append({
                        "camera_id": camera_name,
                        "fp_saved": gain["fp_saved"],
                        "tp_lost": gain["tp_lost"],
                        "cost_ratio": camera.cost_ratio,
                        "threshold": camera.threshold,
                        "model": camera
                    })
                else:
                    self.skipped.append(camera_name)

            except Exception as e:
                logger.warning(f"Error fitting camera {camera_name}: {e}")
                self.skipped.append(camera_name)

    def run(self, target_fp_reduction: int):
        """
        Run greedy optimization using fitted camera models.

        Args:
            target_fp_reduction (int): Desired FP reduction goal.
        """
        self.target_fp_reduction = target_fp_reduction

        if not self.cameras_info:
            self._fit_cameras()

        self.cameras_info.sort(key=lambda x: x["cost_ratio"])

        self.selected = []
        self.total_fp_saved = 0
        self.total_tp_lost = 0

        for cam in self.cameras_info:
            if self.total_fp_saved >= target_fp_reduction:
                break
            self.selected.append(cam["camera_id"])
            self.total_fp_saved += cam["fp_saved"]
            self.total_tp_lost += cam["tp_lost"]

        summary = (
            "\nOptimization Summary\n"
            f"Target FP reduction : {self.target_fp_reduction}\n"
            f"Total FP saved      : {self.total_fp_saved}\n"
            f"Total TP lost       : {self.total_tp_lost}\n"
            f"Selected cameras    : {self.selected}\n"
            f"Used                : {len(self.selected)} / {len(self.cameras_info)} cameras"
        )
        if self.skipped:
            summary += f"\nSkipped cameras      : {self.skipped}"

        logger.info(summary)

    def to_dict(self):
        return {
            "target_fp_reduction": self.target_fp_reduction,
            "total_fp_saved": self.total_fp_saved,
            "total_tp_lost": self.total_tp_lost,
            "selected": self.selected,
            "skipped": self.skipped,
            "cameras_info": self.cameras_info
        }

    @classmethod
    def from_dict(cls, data, df):
        obj = cls(df)
        obj.__dict__.update(data)
        return obj

    def save(self, path: str):
        with open(path, "w") as f:
            json.dump(self.to_dict(), f, indent=2)

    @classmethod
    def load(cls, path: str, df):
        with open(path, "r") as f:
            return cls.from_dict(json.load(f), df)

    def __repr__(self):
        return (f"<GreedyCameraSelector target={self.target_fp_reduction} "
                f"| FP saved={self.total_fp_saved}, TP lost={self.total_tp_lost}, "
                f"selected={len(self.selected)}, skipped={len(self.skipped)}>")



================================================
File: optimizer/io_utils.py
================================================
import os
import pandas as pd


THEFT_LABELS = [
    'Suspicious Bag', 'Suspicious', 'Theft',
    'Gesture Into Body', 'Product Into Stroller'
]


def load_dataframe(csv_path: str) -> pd.DataFrame:
    """
    Loads, cleans, and annotates the production alerts metadata CSV.

    - Reads CSV with ';' delimiter
    - Drops NaNs
    - Creates 'is_theft' column based on label list
    - Extracts 'camera_id' from 'video_name'

    Args:
        csv_path (str): Path to the CSV file.

    Returns:
        pd.DataFrame: Cleaned and processed DataFrame.
    """
    if not os.path.exists(csv_path):
        raise FileNotFoundError(f"File not found: {csv_path}")

    df = pd.read_csv(csv_path, delimiter=";", index_col=0)
    df.dropna(inplace=True)

    df['is_theft'] = df['label'].isin(THEFT_LABELS).astype(int)
    df['camera_id'] = df['video_name'].str.extract(r'camera_(\d+)_ip')

    return df



================================================
File: optimizer/local_optim.py
================================================
import os
import json
import numpy as np
import logging
from datetime import datetime
from sklearn.metrics import precision_score, recall_score, f1_score

from .base_models import BaseCameraModel

logger = logging.getLogger(__name__)


class CameraModel(BaseCameraModel):
    """
    A threshold-based model for a single camera that learns an optimal threshold
    to classify theft events using a selected optimization strategy with included persistence.
    """

    def fit(self, X, y, method="cost", nrb_steps=2000, verbose=True):
        """
        Fit camera prediction model by selecting an optimal threshold based on prediction scores and labels.

        Available methods:
            - 'cost': Minimizes true positives lost per false positive saved.
                Optional kwargs:
                    - steps (int): Number of thresholds to evaluate (default: 500)
            - 'greedy': Greedily increases threshold to reduce cost until no further improvement.
                Optional kwargs:
                    - steps (int): Number of thresholds to evaluate (default: 500)

        Time Complexity:
            O(T × n), where:
                T = number of thresholds (default 500 or as set by `steps`)
                n = number of samples

        Args:
            X (np.ndarray): Prediction scores (probabilities), shape (n_samples,).
            y (np.ndarray): Binary labels (1 = theft, 0 = non-theft), shape (n_samples,).
            method (str): Optimization strategy to use ('cost' or 'greedy').
            **kwargs: Additional arguments passed to the selected method.
        """
        self.optim_method = method
        self._fitted = False

        self.baseline_tp, self.baseline_fp = self._compute_tp_fp(X, y, threshold=self.threshold)

        if method == "cost":
            best_th = self._fit_cost(X, y, steps=nrb_steps)
        elif method == "greedy":
            best_th = self._fit_greedy(X, y, steps=nrb_steps)
        else:
            raise ValueError(f"Unknown optimization method: {method}")

        self.threshold = best_th
        self.optimal_tp, self.optimal_fp = self._compute_tp_fp(X, y, threshold=best_th)
        self.tp_lost = self.baseline_tp - self.optimal_tp
        self.fp_saved = self.baseline_fp - self.optimal_fp
        self.cost_ratio = self._compute_cost_ratio(self.tp_lost, self.fp_saved)

        self._fitted = True
        self.updated_at = datetime.now()

        if verbose:
            logger.info(f"Finished fitting camera {self.camera_id}")
            logger.debug(f" - Best threshold: {self.threshold:.4f}")
            logger.debug(f" - TP lost: {self.tp_lost}")
            logger.debug(f" - FP saved: {self.fp_saved}")
            logger.debug(f" - Cost ratio: {self.cost_ratio:.4f}")

    def _compute_cost_ratio(self, tp_lost, fp_saved):
        """Compute the cost as true positives lost per false positive saved."""
        return float("inf") if fp_saved <= 0 else tp_lost / (fp_saved + 1e-8)

    def _fit_cost(self, X, y, steps=500):
        """Grid search for optimal threshold minimizing TP lost / FP saved."""
        thresholds = np.linspace(0, 1, steps)
        base_tp, base_fp = self.baseline_tp, self.baseline_fp

        if base_fp == 0 or base_tp == 0:
            return self.threshold

        best_score = np.inf
        best_th = self.threshold

        for th in thresholds:
            tp, fp = self._compute_tp_fp(X, y, threshold=th)
            delta_tp = base_tp - tp
            delta_fp = base_fp - fp

            if delta_fp <= 0:
                continue

            cost = delta_tp / (delta_fp + 1e-8)
            if cost < best_score or (cost == best_score and th > best_th):
                best_score = cost
                best_th = th

        return best_th

    def _fit_greedy(self, X, y, steps=500):
        """Greedily increase threshold to reduce cost until no further gain."""
        thresholds = np.linspace(0, 1, steps)
        base_tp, base_fp = self.baseline_tp, self.baseline_fp

        if base_fp == 0 or base_tp == 0:
            return self.threshold

        best_th = self.threshold
        best_cost = float("inf")

        for th in thresholds:
            tp, fp = self._compute_tp_fp(X, y, threshold=th)
            delta_tp = base_tp - tp
            delta_fp = base_fp - fp

            if delta_fp <= 0:
                continue

            cost = self._compute_cost_ratio(delta_tp, delta_fp)

            if cost < best_cost:
                best_cost = cost
                best_th = th
            else:
                break

        return best_th

    def _apply_threshold(self, X, threshold):
        """Apply binary threshold to scores."""
        return (X >= threshold).astype(int)

    def _compute_tp_fp(self, X, y, threshold):
        """Compute true positives and false positives for given threshold."""
        preds = self._apply_threshold(X, threshold)
        tp = np.sum((preds == 1) & (y == 1))
        fp = np.sum((preds == 1) & (y == 0))
        return tp, fp

    def report_gain(self):
        """Return dict of TP/FP gain/loss and selected threshold."""
        if not self._fitted:
            raise RuntimeError("Model must be fit before reporting gain.")
        return {
            "baseline_tp": self.baseline_tp,
            "baseline_fp": self.baseline_fp,
            "optimal_tp": self.optimal_tp,
            "optimal_fp": self.optimal_fp,
            "tp_lost": self.tp_lost,
            "fp_saved": self.fp_saved,
            "threshold": self.threshold,
            "cost_method": self.optim_method,
            "cost_ratio": self.cost_ratio
        }

    def predict(self, X):
        """Return binary predictions using the fitted threshold."""
        if not self._fitted:
            raise RuntimeError("Model must be fit before predicting.")
        return self._apply_threshold(X, self.threshold)

    def score(self, X, y, metric="recall"):
        """
        Compute a classification metric.

        Args:
            X (np.ndarray): Scores, shape (n_samples,).
            y (np.ndarray): Labels, shape (n_samples,).
            metric (str): 'recall', 'precision', or 'f1'.

        Returns:
            float: Metric score.
        """
        if not self._fitted:
            raise RuntimeError("Model must be fit before scoring.")
        preds = self.predict(X)

        if metric == "recall":
            return recall_score(y, preds, zero_division=0)
        elif metric == "precision":
            return precision_score(y, preds, zero_division=0)
        elif metric == "f1":
            return f1_score(y, preds, zero_division=0)
        else:
            raise ValueError(f"Unsupported metric: {metric}")

    def to_dict(self):
        """Serialize model to dictionary."""
        return {
            "camera_id": self.camera_id,
            "threshold": self.threshold,
            "cost_ratio": self.cost_ratio,
            "tp_lost": self.tp_lost,
            "fp_saved": self.fp_saved,
            "optim_method": self.optim_method,
            "updated_at": self.updated_at.isoformat()
        }

    @classmethod
    def from_dict(cls, data):
        """Deserialize model from dictionary."""
        obj = cls(camera_id=data["camera_id"])
        for attr in ["threshold", "cost_ratio", "tp_lost", "fp_saved", "optim_method"]:
            setattr(obj, attr, data[attr])
        obj.updated_at = datetime.fromisoformat(data["updated_at"])
        obj._fitted = True
        return obj

    def save(self, path):
        """Save model to disk as JSON."""
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, "w") as f:
            json.dump(self.to_dict(), f, indent=2)

    @classmethod
    def load(cls, path):
        """Load model from disk."""
        with open(path, "r") as f:
            data = json.load(f)
        return cls.from_dict(data)

    def __repr__(self):
        return (f"{self.__class__.__name__}(cam={self.camera_id}, "
                f"th={self.threshold:.2f}, cost_ratio={self.cost_ratio:.4f}, "
                f"method={self.optim_method}, "
                f"updated={self.updated_at.strftime('%Y-%m-%d %H:%M:%S')})")



================================================
File: optimizer/viz_utils.py
================================================




================================================
File: tests/__init__.py
================================================


